/* * DeepImageJ *  * https://deepimagej.github.io/deepimagej/ * * Conditions of use: You are free to use this software for research or educational purposes.  * In addition, we expect you to include adequate citations and acknowledgments whenever you  * present or publish results that are based on it. *  * Reference: DeepImageJ: A user-friendly plugin to run deep learning models in ImageJ * E. Gomez-de-Mariscal, C. Garcia-Lopez-de-Haro, L. Donati, M. Unser, A. Munoz-Barrutia, D. Sage.  * Submitted 2019. * * Bioengineering and Aerospace Engineering Department, Universidad Carlos III de Madrid, Spain * Biomedical Imaging Group, Ecole polytechnique federale de Lausanne (EPFL), Switzerland * * Corresponding authors: mamunozb@ing.uc3m.es, daniel.sage@epfl.ch * *//* * Copyright 2019. Universidad Carlos III, Madrid, Spain and EPFL, Lausanne, Switzerland. *  * This file is part of DeepImageJ. *  * DeepImageJ is free software: you can redistribute it and/or modify it under the terms of  * the GNU General Public License as published by the Free Software Foundation, either  * version 3 of the License, or (at your option) any later version. *  * DeepImageJ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  * See the GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License along with DeepImageJ.  * If not, see <http://www.gnu.org/licenses/>. */package deepimagej.processing;import java.io.File;/*** This is a fairly uptight security manager subclass. Classes loaded by* the PluginClassLoader are highly restricted in what they are allowed to do.* This is okay, because they're only supposed to calculate some values,* for which all necessary data is already available to them.** A SecurityManager consists of various methods that the system calls to* check whether certain sensitive operations should be allowed. These* methods can throw a SecurityException to prevent the operation from* happening. With this SecurityManager, we want to prevent untrusted* code that was loaded by a class loader from performing those sensitive operations.* So we use inherited SecurityManager methods to check whether the call is being* made by an untrusted class. If it is, we throw an exception.* Otherwise, we simply return, allowing the operation to proceed normally.*/public class PluginSecurityManager extends SecurityManager {	private String pluginDir = null;	PluginSecurityManager (String dir) {		pluginDir = dir;	}	/**	 * This is the basic method that tests whether there is a class loaded	 * by a ClassLoader anywhere on the stack. If so, it means that that	 * untrusted code is trying to perform some kind of sensitive operation.	 * We prevent it from performing that operation by throwing an exception.	 * trusted() is called by most of the check...() methods below.	 */	protected void trusted() {		if (inClassLoader()) throw new SecurityException();	}	/**	 * These are all the specific checks that a security manager can	 * perform. They all just call one of the methods above and throw a	 * SecurityException if the operation is not allowed. This 	 * SecurityManager subclass is perhaps a little too restrictive. For	 * example, it doesn't allow loaded code to read *any* system properties,	 * even though some of them are quite harmless.	 */	public void checkCreateClassLoader() { trusted(); }	public void checkAccess (Thread g) { trusted(); }	public void checkAccess (ThreadGroup g) { trusted(); }	public void checkExit (int status) { trusted(); }	public void checkExec (String cmd) { trusted(); }	public void checkLink (String lib) { trusted(); }	public void checkRead (java.io.FileDescriptor fd) { trusted(); }	public void checkRead (String file) {//		String path = new File(file).getParentFile().getAbsolutePath();//		if (! path.endsWith(pluginDir))			trusted();	}	public void checkRead (String file, Object context) { trusted(); }	public void checkWrite (java.io.FileDescriptor fd) { trusted(); }	public void checkWrite (String file) { trusted(); }	public void checkDelete (String file) { trusted(); }	public void checkConnect (String host, int port) { trusted(); }	public void checkConnect (String host,int port,Object context) {trusted();}	public void checkListen (int port) { trusted(); }	public void checkAccept (String host, int port) { trusted(); }	public void checkMulticast (java.net.InetAddress maddr) { trusted(); }	public void checkMulticast (java.net.InetAddress maddr, byte ttl) { trusted(); }	public void checkPropertiesAccess() { trusted(); }	public void checkPropertyAccess (String key) {//		if (! key.equals("user.dir"))			trusted();	}	public void checkPrintJobAccess() { trusted(); }	public void checkSystemClipboardAccess() { trusted(); }	public void checkAwtEventQueueAccess() { trusted(); }	public void checkSetFactory() { trusted(); }	public void checkMemberAccess (Class clazz, int which) { trusted(); }	public void checkSecurityAccess (String provider) { trusted(); }	/** Loaded code can only load classes from java.* packages */	public void checkPackageAccess (String pkg) { 		if (inClassLoader() && !pkg.startsWith("java.") && !pkg.startsWith("javax."))			throw new SecurityException();	}	/** Loaded code can't define classes in java.* or sun.* packages */	public void checkPackageDefinition (String pkg) { 		if (inClassLoader() && ((pkg.startsWith("java.") || pkg.startsWith("javax.") || pkg.startsWith("sun."))))			throw new SecurityException();	}	/** 	 * This is the one SecurityManager method that is different from the	 * others. It indicates whether a top-level window should display an	 * "untrusted" warning. The window is always allowed to be created, so	 * this method is not normally meant to throw an exception. It should	 * return true if the window does not need to display the warning, and	 * false if it does. In this example, however, our text-based Service	 * classes should never need to create windows, so we will actually	 * throw an exception to prevent any windows from being opened.	 **/	public boolean checkTopLevelWindow (Object window) { 		trusted();		return true; 	}}